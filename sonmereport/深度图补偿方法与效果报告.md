# 深度图补偿方法与效果报告

**生成日期**: 2025年12月19日  
**项目**: 深度图补偿系统 v3.0

---

## 1. 项目背景

深度图测量系统存在非线性误差，导致测量值与实际值之间存在偏差。本项目通过建立补偿模型，对深度图进行校正，提高测量精度。

### 1.1 核心问题

- **深度非线性**: 测量值与实际值之间存在非线性关系
- **空间变化**: 不同X位置的响应曲线可能不同（弧形畸变）
- **补偿目标**: 将线性度从 ~0.44% 降低至 <0.05%

---

## 2. 补偿算法概述

### 2.1 算法列表

| 算法 | 代码标识 | 参数量 | 特点 |
|------|---------|--------|------|
| **2D多项式(2×2)** | `poly2d_2x2` | 13 | 参数最少，速度最快 |
| **2D多项式(3×3)** | `poly2d_3x3` | 20 | ⭐推荐，精度高，泛化能力强 |
| **分区域(8区)** | `regional_8` | 32 | 将图像分为8个区域独立补偿 |
| **分区域(16区)** | `regional_16` | 64 | 将图像分为16个区域独立补偿 |
| **3次样条** | `cubic_spline` | ~25000 | 高精度拟合，但易过拟合 |

### 2.2 算法原理

#### 2D多项式模型

模型公式：
```
actual = f(x, measured) = Σᵢ Σⱼ cᵢⱼ · xⁱ · zʲ
```

其中：
- `x`: X位置（像素 × 0.0125 mm/pixel）
- `z`: 测量深度值（mm）
- `cᵢⱼ`: 多项式系数

**2×2模型**: i,j ∈ {0,1,2}，共 3×3 = 9 个系数 + 4个归一化参数 = 13参数  
**3×3模型**: i,j ∈ {0,1,2,3}，共 4×4 = 16 个系数 + 4个归一化参数 = 20参数

#### 分区域模型

将图像水平分为N个区域，每个区域使用独立的3次多项式：
```
actual = a₃z³ + a₂z² + a₁z + a₀  (区域内)
```

#### 3次样条模型

使用B样条插值建立测量值到实际值的映射：
```
actual = spline(measured)
```

---

## 3. 实验验证

### 3.1 数据集说明

| 数据集 | 用途 | 图像数量 | 说明 |
|--------|------|----------|------|
| **DataCandT/calib1** | 训练集 | ~50张 | 用于建立补偿模型 |
| **DataCandT/calib2** | 测试集 | ~50张 | 用于验证模型效果 |
| **DataCandT2** | 独立验证 | ~50张 | 完全独立的新数据 |

### 3.2 评估指标

- **线性度 (BFSL)**: 最大偏差 / 满量程 × 100%
- **RMS误差**: 均方根误差
- **改善幅度**: (补偿前线性度 - 补偿后线性度) / 补偿前线性度 × 100%
- **R²**: 决定系数

---

## 4. 补偿效果对比

### 4.1 测试集验证结果 (DataCandT/calib2)

| 算法 | 补偿前线性度 | 补偿后线性度 | 改善幅度 | 参数量 |
|------|-------------|-------------|---------|--------|
| **2D多项式(2×2)** | 0.4400% | 0.0175% | 96.0% | 13 |
| **2D多项式(3×3)** | 0.4400% | 0.0166% | 96.2% | 20 |
| **分区域(8区)** | 0.4400% | 0.0200% | 95.5% | 32 |
| **3次样条** | 0.4400% | 0.0197% | 95.5% | ~25000 |

### 4.2 独立验证结果 (DataCandT2)

| 算法 | 补偿后线性度 | 稳定性评估 |
|------|-------------|-----------|
| **2D多项式(2×2)** | 0.0226% | ✅ 稳定 |
| **2D多项式(3×3)** | 0.0220% | ✅ 稳定 |
| **分区域(8区)** | 0.0250% | ✅ 稳定 |
| **3次样条** | **1.5835%** | ❌ 严重过拟合 |

> ⚠️ **重要发现**: 3次样条在训练集上表现优秀，但在新数据上完全失效，说明存在严重过拟合问题。

---

## 5. 效率对比

### 5.1 计算性能

| 算法 | 训练时间 | 推理时间(单张) | 存储大小 |
|------|---------|---------------|---------|
| **2D多项式(2×2)** | ~50ms | ~41ms | 0.32KB |
| **2D多项式(3×3)** | ~60ms | ~50ms | 0.45KB |
| **分区域(8区)** | ~80ms | ~84ms | 1.2KB |
| **3次样条** | ~200ms | ~85ms | ~50KB |

### 5.2 向量化优化效果

| 实现方式 | 处理时间 (690万像素) |
|---------|---------------------|
| 逐像素Python循环 | **数分钟** |
| NumPy向量化 | **< 1秒** |

**速度提升**: 100-1000倍

---

## 6. 畸变分析

### 6.1 补偿前畸变特征

通过X-Z点阵图分析发现，补偿前的深度偏差呈现**弧形分布**：
- 图像边缘的深度偏差较大
- 图像中心的深度偏差较小
- 深度响应斜率变化范围：3.71%

### 6.2 补偿后效果

使用2D多项式模型补偿后：
- 弧形畸变基本消除
- 各列的深度偏差趋于一致
- 线性度大幅改善

### 6.3 镜头畸变 vs 深度畸变

#### 关键发现：两种畸变是不同的问题

| 畸变类型 | 影响对象 | 参数来源 | 补偿效果 |
|---------|---------|---------|---------|
| **镜头畸变** | XY像素位置 | Calibration.json (k1,k2,k3,τx,τy) | 0.04%改善 |
| **深度畸变** | Z深度值 | 线性模型反推 | 1.27%改善 |
| **深度非线性** | Z与X的复合关系 | 2D多项式拟合 | **94.87%改善** |

#### 误差来源分解

```
┌─────────────────────────────────────────────────────────────┐
│              深度测量误差的真正来源                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  镜头畸变 (k1,k2,k3,τx,τy):                                  │
│    → 影响: 像素位置 (X, Y)                                   │
│    → 用途: 图像去畸变                                        │
│    → 对深度值 Z: 间接影响（需要先校正位置）                    │
│                                                             │
│  深度非线性:                                                 │
│    → 影响: 深度值 Z                                          │
│    → 特点: 非线性函数 measured = f(x, actual)                │
│    → 需要: 专门的深度补偿模型（如2D多项式）                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.4 高阶畸变系数解析 (14参数模型)

原始标定数据 `Calibration.json` 包含14参数高阶畸变模型：

#### 参数结构

```
dist_coeffs[14] = [k1, k2, p1, p2, k3, k4, k5, k6, s1, s2, s3, s4, τx, τy]
```

#### 参数值

| 参数类型 | 系数 | 值 | 说明 |
|---------|------|-----|------|
| **径向畸变(低阶)** | k1 | -0.0703 | 主要项，负值=枕形畸变 |
| | k2 | 0.8485 | 高阶修正 |
| | k3 | -2.9084 | 更高阶修正 |
| **径向畸变(高阶)** | k4,k5,k6 | 0 | rational模型(未使用) |
| **切向畸变** | p1 | 0.0008 | 几乎为零，可忽略 |
| | p2 | -0.0005 | 几乎为零，可忽略 |
| **薄棱镜畸变** | s1,s2,s3,s4 | 0 | 未使用 |
| **倾斜传感器** | τx | **-0.2153** | ⚠️ 显著非零！ |
| | τy | 0.0055 | 较小 |

#### τx 参数的物理意义

```
τx = -0.2153 ≈ -12.3° 倾斜角

这个参数描述了传感器平面相对于光轴的倾斜，
是弧形畸变的物理根源！
```

#### 畸变校正因子

| 位置 | 校正因子 | 变化 |
|------|---------|------|
| 边缘(左) | 0.966 | -3.4% |
| 中心 | 1.011 | +1.1% |
| 边缘(右) | 1.064 | +6.4% |
| **总变化范围** | | **9.7%** |

### 6.5 为什么高阶畸变系数不能直接用于深度补偿？

| 尝试方法 | 线性度改善 | 原因 |
|---------|-----------|------|
| 直接应用镜头畸变校正 | -1.11% (变差) | 畸变系数针对XY位置，不是Z值 |
| 简单线性深度模型 | 1.27% | 假设过于简单 |
| **2D多项式(3×3)** | **94.87%** | 正确拟合非线性关系 |

#### 结论

1. **Calibration.json中的畸变系数(k1,k2,k3,τx等)是镜头畸变参数**
   - 设计用于图像XY平面的像素位置校正
   - 相机未启用畸变校正时，这些参数未被应用

2. **深度测量误差是另一个问题**
   - 需要专门的深度补偿模型
   - 2D多项式隐式包含了所有需要的校正

3. **τx ≠ 0 解释了弧形畸变的物理来源**
   - 传感器倾斜导致空间位置相关的深度误差
   - 但直接应用τx校正无法解决深度非线性问题

### 6.6 建议的完整校正流程

```
┌─────────────────────────────────────────────────────────────┐
│                    推荐的校正流程                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  方案A (完整校正):                                           │
│    1. 在相机端启用畸变校正 (使用14参数模型)                    │
│    2. 再使用2D多项式补偿剩余深度非线性                         │
│                                                             │
│  方案B (简化方案，推荐):                                      │
│    直接使用2D多项式(3×3)补偿                                  │
│    → 已隐式包含所有需要的校正                                 │
│    → 效果验证良好 (线性度 0.02%)                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7. 结论与建议

### 7.1 算法推荐

| 排名 | 算法 | 推荐理由 |
|------|------|---------|
| **1** | 2D多项式(3×3) | 精度最高，泛化能力强，参数适中 |
| **2** | 2D多项式(2×2) | 参数最少，速度最快，适合资源受限场景 |
| **3** | 分区域(8区) | 简单直观，便于理解和调试 |
| ❌ | 3次样条 | 不推荐，泛化能力差，易过拟合 |

### 7.2 最终推荐

**推荐使用: 2D多项式(3×3)**

理由：
1. ✅ 线性度最佳 (0.0166%)
2. ✅ 泛化能力强，在新数据上稳定
3. ✅ 参数量适中 (20个)
4. ✅ 计算速度快 (~50ms/张)
5. ✅ 存储空间小 (0.45KB)

### 7.3 关键经验

1. **避免过拟合**: 必须使用独立测试集验证模型
2. **向量化计算**: 使用NumPy向量化可提升100倍以上速度
3. **2D建模**: 考虑空间位置(X坐标)的模型优于全局单一模型
4. **参数权衡**: 更多参数不一定更好，需平衡精度与泛化
5. **区分畸变类型**: 镜头畸变(XY位置)≠深度畸变(Z值)，需分别处理
6. **理解物理根源**: τx=-0.2153(传感器倾斜)是弧形畸变的物理来源

---

## 8. 技术实现

### 8.1 核心文件

| 文件 | 功能 |
|------|------|
| `compensator_multi.py` | 多算法补偿核心模块 |
| `ui/app.py` | 图形用户界面 |
| `linearity_calc.py` | 线性度计算工具 |
| `calibrator.py` | 图像标定处理 |
| `experiment_high_order_distortion_coeffs.py` | 高阶畸变系数分析 |
| `experiment_depth_distortion_model.py` | 深度畸变模型实验 |

### 8.2 使用方法

```python
from compensator_multi import load_model_multi, compensate_image_multi

# 加载模型
model = load_model_multi("model_poly2d_3x3.json")

# 补偿图像
result = compensate_image_multi(depth_array, model)
compensated = result['compensated_array']
```

---

## 附录：模型参数示例

### 2D多项式(3×3)模型结构

```json
{
  "algorithm": "poly2d_3x3",
  "coefficients": [c00, c01, c02, c03, c10, c11, c12, c13, c20, c21, c22, c23, c30, c31, c32, c33],
  "x_degree": 3,
  "z_degree": 3,
  "x_mean": 20.0,
  "x_std": 11.5,
  "z_mean": 21.0,
  "z_std": 12.0,
  "num_params": 20
}
```

### 附录B：高阶畸变系数 (Calibration.json)

```json
{
  "dist_coeffs": [
    -0.070278,   // k1: 径向畸变(主要)
     0.848486,   // k2: 径向畸变(高阶)
     0.000828,   // p1: 切向畸变
    -0.000450,   // p2: 切向畸变
    -2.908390,   // k3: 径向畸变(高阶)
     0.000000,   // k4: rational模型(未用)
     0.000000,   // k5: rational模型(未用)
     0.000000,   // k6: rational模型(未用)
     0.000000,   // s1: 薄棱镜(未用)
     0.000000,   // s2: 薄棱镜(未用)
     0.000000,   // s3: 薄棱镜(未用)
     0.000000,   // s4: 薄棱镜(未用)
    -0.215309,   // τx: 倾斜传感器 ⚠️重要
     0.005483    // τy: 倾斜传感器
  ],
  "intrinsic": {
    "fx": 7212.68,
    "fy": 7212.68,
    "cx": 1242.09,
    "cy": 880.35
  }
}
```

---

**报告结束**

*深度图补偿系统 v3.0 Multi-Algorithm Edition*

