# 三次样条补偿模型参数详解

## 1. 模型文件结构

以 `compensation_model1.json` 为例，完整的模型参数如下：

```json
{
  "model_type": "cubic_spline",
  "version": "2.2",
  "knots": [...],        // 节点向量 (46个值)
  "coefficients": [...], // 样条系数 (46个值)
  "k": 3,                // 样条阶数
  "x_range": [-24.0956, 17.5476],  // 输入范围
  "y_range": [0.9998, 41.9978],    // 输出范围
  "calibration_points": 42         // 标定点数
}
```

---

## 2. 参数详细说明

### 2.1 model_type（模型类型）

| 值 | 说明 |
|---|------|
| `"cubic_spline"` | 三次样条插值模型 |

三次样条是一种分段多项式插值方法，在每个区间内使用三次多项式，保证整体曲线的光滑性（二阶连续可导）。

### 2.2 version（版本号）

| 值 | 说明 |
|---|------|
| `"2.2"` | 模型格式版本，用于兼容性检查 |

### 2.3 k（样条阶数）

| 值 | 说明 |
|---|------|
| `3` | 三次样条 (cubic spline) |

样条阶数决定了多项式的次数：
- k=1: 线性样条（分段直线）
- k=2: 二次样条
- k=3: 三次样条（最常用，光滑性好）

### 2.4 knots（节点向量）

```
节点向量 t = [t_0, t_1, t_2, ..., t_{n+k}]
```

| 属性 | 值 |
|------|-----|
| 数量 | 46 个节点 |
| 范围 | -24.095556 ~ 17.547588 |
| 单位 | 毫米 (mm) |

**节点向量的特点：**

```
前4个节点（重复）:
  t[0] = t[1] = t[2] = t[3] = -24.095556  (边界条件)

中间节点（唯一）:
  t[4] = -22.145266
  t[5] = -21.167919
  ...
  t[41] = 15.438356

后4个节点（重复）:
  t[42] = t[43] = t[44] = t[45] = 17.547588  (边界条件)
```

**边界重复的原因：**
- 对于 k 阶样条，边界需要重复 k+1 次
- 这确保了样条曲线在端点处的正确行为
- 三次样条 (k=3) 需要重复 4 次

### 2.5 coefficients（样条系数）

```
系数向量 c = [c_0, c_1, c_2, ..., c_{n-1}]
```

| 属性 | 值 |
|------|-----|
| 数量 | 46 个系数 |
| 范围 | 0.9998 ~ 41.9978（有效系数） |
| 单位 | 毫米 (mm) |

**系数分布：**

```
有效系数（前42个）:
  c[0]  = 0.9998   → 对应 ~1mm 位置
  c[1]  = 1.668702 → 对应 ~2mm 位置
  ...
  c[41] = 41.9978  → 对应 ~42mm 位置

填充系数（后4个）:
  c[42] = c[43] = c[44] = c[45] = 0.0  (边界填充)
```

### 2.6 x_range（输入范围）

| 参数 | 值 | 说明 |
|------|-----|------|
| 最小值 | -24.0956 mm | 测量值下限 |
| 最大值 | 17.5476 mm | 测量值上限 |
| 跨度 | 41.64 mm | 有效测量范围 |

**x 代表深度相机的原始测量值**（经过单位转换后的毫米值）

### 2.7 y_range（输出范围）

| 参数 | 值 | 说明 |
|------|-----|------|
| 最小值 | 0.9998 mm | 实际值下限 |
| 最大值 | 41.9978 mm | 实际值上限 |
| 跨度 | 40.998 mm | 有效标定范围 |

**y 代表补偿后的实际距离值**（标定时的真实位移）

### 2.8 calibration_points（标定点数）

| 值 | 说明 |
|---|------|
| 42 | 成功标定的数据点数量 |

注意：原始 CSV 有 45 个点，但部分可能被过滤（3σ 异常值剔除）

---

## 3. 三次B样条数学原理

### 3.1 B样条基函数

三次B样条由基函数 $B_{i,k}(x)$ 的线性组合构成：

$$S(x) = \sum_{i=0}^{n-1} c_i \cdot B_{i,k}(x)$$

其中：
- $S(x)$ 是样条函数值（补偿后的值）
- $c_i$ 是第 i 个系数
- $B_{i,k}(x)$ 是第 i 个 k 阶 B样条基函数

### 3.2 B样条基函数的递归定义

**零阶 (k=0)：**
$$B_{i,0}(x) = \begin{cases} 1 & \text{if } t_i \leq x < t_{i+1} \\ 0 & \text{otherwise} \end{cases}$$

**高阶 (k>0)：**
$$B_{i,k}(x) = \frac{x - t_i}{t_{i+k} - t_i} B_{i,k-1}(x) + \frac{t_{i+k+1} - x}{t_{i+k+1} - t_{i+1}} B_{i+1,k-1}(x)$$

### 3.3 简化理解

对于实际应用，可以将补偿过程理解为：

```
输入 x（测量值）→ 查找所在区间 → 计算局部多项式 → 输出 y（实际值）
```

每个区间内，三次样条可以表示为：
$$y = a_0 + a_1(x-x_0) + a_2(x-x_0)^2 + a_3(x-x_0)^3$$

---

## 4. 补偿流程详解

### 4.1 完整补偿流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                         深度图像补偿流程                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ① 读取深度图像                                                      │
│     │                                                               │
│     ▼                                                               │
│  ┌─────────────────────┐                                            │
│  │ 16位 PNG 像素值     │  例如: pixel = 32768                        │
│  │ 范围: 0 ~ 65535     │                                            │
│  └─────────┬───────────┘                                            │
│            │                                                        │
│  ② 像素值转毫米                                                      │
│     │      │                                                        │
│     ▼      ▼                                                        │
│  ┌─────────────────────┐                                            │
│  │ x = pixel × 满量程  │  公式: x = 32768 × 43 / 65535              │
│  │     ────────────    │        x ≈ 21.5 mm                         │
│  │        65535        │                                            │
│  └─────────┬───────────┘                                            │
│            │                                                        │
│  ③ 样条插值补偿                                                      │
│     │      │                                                        │
│     ▼      ▼                                                        │
│  ┌─────────────────────┐                                            │
│  │ y = splev(x, tck)   │  使用节点和系数计算                         │
│  │ tck = (t, c, k)     │  y ≈ 21.8 mm (补偿后)                       │
│  └─────────┬───────────┘                                            │
│            │                                                        │
│  ④ 毫米转像素值                                                      │
│     │      │                                                        │
│     ▼      ▼                                                        │
│  ┌─────────────────────┐                                            │
│  │ new_pixel = y × 65535 │  公式: new_pixel = 21.8 × 65535 / 43     │
│  │            ───────── │        new_pixel ≈ 33225                   │
│  │              满量程   │                                            │
│  └─────────┬───────────┘                                            │
│            │                                                        │
│  ⑤ 保存补偿后图像                                                    │
│     │                                                               │
│     ▼                                                               │
│  ┌─────────────────────┐                                            │
│  │ 16位 PNG 文件       │                                            │
│  └─────────────────────┘                                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 Python 代码实现

```python
import numpy as np
from scipy.interpolate import splev
import json

def load_model(filepath):
    """加载补偿模型"""
    with open(filepath, 'r') as f:
        model = json.load(f)
    
    # 构造样条元组 (t, c, k)
    tck = (
        np.array(model['knots']),
        np.array(model['coefficients']),
        model['k']
    )
    return tck, model['x_range']

def compensate_pixel(pixel_value, tck, x_range, full_scale=43.0):
    """
    补偿单个像素值
    
    参数:
        pixel_value: 原始16位像素值 (0-65535)
        tck: 样条元组 (knots, coefficients, k)
        x_range: 模型有效范围 [x_min, x_max]
        full_scale: 满量程 (mm)
    
    返回:
        补偿后的16位像素值
    """
    # 特殊值处理（无效像素）
    if pixel_value == 65535 or pixel_value == 0:
        return pixel_value
    
    # 步骤1: 像素值 → 毫米
    x_mm = pixel_value * full_scale / 65535.0
    
    # 步骤2: 范围检查
    x_min, x_max = x_range
    if x_mm < x_min:
        x_mm = x_min  # 限制到最小值
    elif x_mm > x_max:
        x_mm = x_max  # 限制到最大值
    
    # 步骤3: 样条插值计算补偿值
    y_mm = float(splev(x_mm, tck))
    
    # 步骤4: 毫米 → 像素值
    new_pixel = int(y_mm * 65535.0 / full_scale)
    
    # 步骤5: 确保在有效范围内
    new_pixel = max(0, min(65534, new_pixel))
    
    return new_pixel

def compensate_image(depth_array, tck, x_range, full_scale=43.0):
    """
    补偿整幅深度图像
    
    参数:
        depth_array: 深度图像数组 (H x W, uint16)
        tck: 样条元组
        x_range: 模型有效范围
        full_scale: 满量程 (mm)
    
    返回:
        补偿后的深度图像数组
    """
    # 创建输出数组（保留无效值）
    compensated = depth_array.copy()
    
    # 创建有效像素掩码
    valid_mask = (depth_array > 0) & (depth_array < 65535)
    
    # 批量转换为毫米
    x_mm = depth_array[valid_mask].astype(np.float64) * full_scale / 65535.0
    
    # 限制范围
    x_min, x_max = x_range
    x_mm = np.clip(x_mm, x_min, x_max)
    
    # 批量样条插值
    y_mm = splev(x_mm, tck)
    
    # 转换回像素值
    new_pixels = (y_mm * 65535.0 / full_scale).astype(np.uint16)
    new_pixels = np.clip(new_pixels, 0, 65534)
    
    # 写入结果
    compensated[valid_mask] = new_pixels
    
    return compensated
```

### 4.3 补偿示例

```python
# 加载模型
tck, x_range = load_model('compensation_model1.json')

# 示例：补偿一个像素值
pixel = 32768  # 中间值

# 步骤分解:
# 1. 像素转毫米: x = 32768 * 43 / 65535 = 21.50 mm
# 2. 样条插值:   y = splev(21.50, tck) ≈ 21.xx mm
# 3. 毫米转像素: new = 21.xx * 65535 / 43 ≈ 3xxxx

compensated = compensate_pixel(pixel, tck, x_range, full_scale=43.0)
print(f"原始像素: {pixel} → 补偿后: {compensated}")
```

---

## 5. 模型参数之间的关系

### 5.1 参数数量关系

```
设 n = 标定点数 = 42
设 k = 样条阶数 = 3

节点数量 = n + k + 1 = 42 + 3 + 1 = 46 ✓
系数数量 = n + k + 1 = 42 + 3 + 1 = 46 ✓
有效系数 = n = 42
边界填充 = k + 1 = 4
```

### 5.2 节点与系数的对应

```
                    节点向量 (knots)
    ├────────────────────────────────────────────┤
    │ 重复4次  │      中间节点（唯一）    │ 重复4次  │
    │ t[0:4]  │       t[4:42]          │ t[42:46]│
    └─────────┴────────────────────────┴─────────┘
         │                                   │
         ▼                                   ▼
    边界条件                              边界条件
    
                   系数向量 (coefficients)
    ├────────────────────────────────────────────┤
    │           有效系数           │    填充0    │
    │          c[0:42]            │   c[42:46]  │
    └──────────────────────────────┴─────────────┘
         │
         ▼
    对应42个标定点的补偿值
```

### 5.3 x_range 与 y_range 的含义

```
           输入空间 (测量值)              输出空间 (实际值)
    ┌──────────────────────────┐    ┌──────────────────────────┐
    │                          │    │                          │
    │  x_range:                │    │  y_range:                │
    │  [-24.0956, 17.5476] mm  │───▶│  [0.9998, 41.9978] mm    │
    │                          │    │                          │
    │  这是相机测量到的值       │    │  这是标定时的真实位移     │
    │  （带有系统误差）         │    │  （高精度位移台）         │
    │                          │    │                          │
    └──────────────────────────┘    └──────────────────────────┘
    
    补偿的本质：将有误差的测量值映射到真实值
```

---

## 6. 为什么使用三次样条？

### 6.1 优点

| 特性 | 说明 |
|------|------|
| **连续性** | 二阶导数连续，曲线光滑无突变 |
| **局部性** | 修改一个点只影响邻近区域 |
| **精确性** | 穿过所有标定点（插值，非拟合） |
| **稳定性** | 不会产生龙格现象（高次多项式的振荡） |
| **高效性** | 计算速度快，适合实时补偿 |

### 6.2 与其他方法的对比

| 方法 | 优点 | 缺点 |
|------|------|------|
| 线性插值 | 简单 | 不光滑，精度低 |
| 多项式拟合 | 全局平滑 | 高次振荡，边界不稳定 |
| **三次样条** | **光滑、稳定、精确** | 略复杂 |
| 查找表 (LUT) | 极快 | 需大量存储，精度受限 |

---

## 7. 模型应用注意事项

### 7.1 范围限制

```python
# 模型只在 x_range 内有效
x_min, x_max = -24.0956, 17.5476

if x < x_min or x > x_max:
    # 需要外推或限制
    # 选项1: 线性外推
    # 选项2: 钳位到边界
    pass
```

### 7.2 无效值处理

```python
INVALID_VALUE = 65535  # 无效像素标记

if pixel == INVALID_VALUE:
    return INVALID_VALUE  # 保持无效标记
```

### 7.3 满量程设置

```python
# 满量程必须与标定时一致
FULL_SCALE = 43.0  # mm

# 错误的满量程会导致补偿结果完全错误！
```

---

## 8. 总结

| 参数 | 作用 | 本模型值 |
|------|------|----------|
| model_type | 标识模型类型 | cubic_spline |
| version | 格式版本 | 2.2 |
| knots | B样条节点向量 | 46个值 |
| coefficients | B样条系数 | 46个值（42有效+4填充） |
| k | 样条阶数 | 3（三次） |
| x_range | 有效输入范围 | [-24.10, 17.55] mm |
| y_range | 有效输出范围 | [1.00, 42.00] mm |
| calibration_points | 标定点数 | 42 |

**补偿公式核心：**
$$y = \text{splev}(x, (t, c, k))$$

其中 $x$ 是测量值，$y$ 是补偿后的实际值，$(t, c, k)$ 是模型参数。

---

*报告生成时间：2024年12月18日*

